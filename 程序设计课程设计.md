一、需求和规格说明
1.1 问题描述

2048 是一款经典的数字益智游戏，玩家通过滑动操作使相同数字的方块合并，最终达到 2048 这一目标。本课程设计要求实现一个功能完整、界面美观的 2048 游戏，并满足以下核心需求：

游戏规则实现：4×4 网格，方向键控制，合并相同数字，每次移动后随机生成新方块。

图形用户界面：使用图形库绘制华丽的游戏界面，不同数值的方块使用不同颜色，添加平滑的动画效果。

进度保存功能：用户可随时退出游戏，下次启动时可选择继续或重新开始。

排行榜系统：使用链表数据结构实现用户排名功能，支持插入、修改、删除操作，并持久化到文件。

1.2 功能规格说明

本项目在原题基础上进行了以下完善和补充：

1.2.1 核心游戏逻辑

初始时在随机位置生成两个方块（值为 2 或 4）

支持四个方向的移动（上、下、左、右）

相同数值的方块在移动方向上碰撞时合并，数值相加

每个方块在一次移动中最多合并一次

合并成功后增加分数（分数增量等于合并后的数值）

每次有效移动后在随机空位生成新方块（2 的概率 90%，4 的概率 10%）

当网格填满且无法进行任何移动时游戏结束

出现 2048 方块时判定为胜利（但可继续游戏）

1.2.2 图形界面要求

使用 SFML 图形库实现跨平台的图形界面

不同数值方块使用渐变色系（2 为浅色，2048 为金色）

实现平滑的动画效果：

移动动画：方块从起点滑动到终点（200ms）

合并动画：合并后的方块弹出效果（100ms，缩放 1.0→1.2→1.0）

生成动画：新方块的缩放出现效果（100ms，缩放 0→1.2→1.0）

动画播放期间锁定用户输入，防止状态不一致

1.2.3 菜单系统

主菜单界面，支持鼠标和键盘操作

玩家名称输入功能，支持中英文输入（UTF-8 编码）

根据是否有存档显示不同的菜单选项

排行榜查看界面

1.2.4 数据持久化

游戏进度保存格式（save.txt）：

用户名
分数
v00 v01 v02 v03
v10 v11 v12 v13
v20 v21 v22 v23
v30 v31 v32 v33


排行榜保存格式（ranks.txt）：

用户名1 分数1
用户名2 分数2
...


按分数降序排列

1.2.5 排行榜链表要求

使用单向链表存储排名信息

节点包含用户名、分数和 next 指针

支持按分数降序插入新节点

同名用户只保留最高分（需先删除旧记录再插入新记录）

支持删除指定用户记录

程序启动时从文件加载链表，结束时保存回文件

二、设计
2.1 设计思想

本项目采用了经典的分层架构设计，将游戏系统划分为四个独立的层次：逻辑层、动画层、渲染层和控制层。这种设计的核心思想是关注点分离（Separation of Concerns），每一层只负责自己的职责，层与层之间通过明确定义的接口通信。

2.1.1 架构分层

逻辑层（Board 类）：这是游戏的"大脑"，只处理纯数学计算。它维护一个 4×4 的整数数组，实现移动、合并、生成新方块等核心算法。关键设计决策是让 Board 类完全不知道像素、动画、渲染等概念，它的所有方法都是纯函数式的，输入网格状态，输出新的网格状态，这使得逻辑层易于测试和维护。

动画层（Animator 类）：动画层负责将逻辑层的"快照对比"转换为平滑的视觉过渡。我采用了事件驱动的设计模式。当用户按下方向键后，游戏会保存移动前的网格快照（gridBefore），调用 Board 计算移动后的快照（gridAfter），然后通过 computeMoveEvents 函数对比两个快照，生成 MoveEvent 事件列表。这些事件描述了"哪个方块从哪里移动到哪里"，Animator 根据这些事件创建 VisualTile 对象并驱动动画。

渲染层（Renderer 类）：渲染层是游戏的"画师"，负责所有的 SFML 绘图调用。它不修改游戏状态，只根据传入的数据绘制画面。关键设计是分层渲染策略：静态时只绘制 Board 的网格；移动动画时只
Game::Game()
: window_(sf::VideoMode(600, 800), "2048 Game"),
renderer_(window_),
state_(GameState::MENU),
wonDisplayed_(false),
menuSelection_(0) {

window_.setFramerateLimit(60);  


绘制 VisualTile 列表（它包含了所有移动的方块）；生成动画时先绘制 Board 背景再叠加绘制新方块的缩放动画。这样设计避免了方块在动画期间"消失"的问题。

控制层（Game 类）：Game 类是整个系统的"指挥官"，它实现了一个状态机（State Machine）来管理游戏流程。状态包括：主菜单（MENU）、游戏中（PLAYING）、胜利（WON）、失败（GAME_OVER）和排行榜（RANK_LIST）。Game 类协调各个模块的工作：接收输入 → 调用逻辑计算 → 生成动画事件 → 驱动动画 → 提交结果 → 保存进度 → 更新排行榜。

2.1.2 关键设计模式

在开发过程中，我发现输入锁定机制至关重要。如果动画还没播放完就允许下一次输入，逻辑层和动画层的状态会不一致，导致方块乱飞。因此我在 Game::processInput 中添加了这样的判断：

if (animator_.isAnimating()) {
    return;  // 动画进行中，忽略输入
}


只有当动画完全播放完毕，才解锁输入，这确保了游戏的稳定性。

另一个重要设计是快照式动画。我没有让动画直接修改 Board 的网格，而是让 Board::simulateMove 返回一个新的网格副本。动画播放时 Board 保持旧状态不变，只有当动画播放完毕后，通过回调函数才真正提交新状态。这种设计使得动画系统和逻辑系统完全解耦，即使动画出现 bug，也不会破坏游戏逻辑。

2.1.3 数据结构选择

排行榜系统使用单向链表实现，这是课程要求的核心数据结构。链表节点（RankNode）包含用户名、分数和 next 指针。链表始终保持按分数降序排列，这样查询最高分只需访问头节点，时间复杂度 O(1)。插入新记录时采用有序插入算法，遍历链表找到正确位置后插入，时间复杂度 O(n)。虽然相比 std::map 或 std::priority_queue 效率略低，但满足了课程设计对基础数据结构的要求，并且排行榜规模通常不大（前 10 名），性能完全可接受。

2.2 程序结构

本项目严格遵循面向对象设计原则，共设计了 7 个类，每个类职责明确、高内聚低耦合。项目采用经典的头文件和实现文件分离的组织方式，便于团队协作和维护。

2.2.1 类图关系（文字描述）

Game 类是核心控制器，它聚合（包含）了其他所有类的实例：

Game 包含 1 个 Board（逻辑层）

Game 包含 1 个 Animator（动画层）

Game 包含 1 个 Renderer（渲染层）

Game 包含 1 个 SaveManager（存档管理）

Game 包含 1 个 RankList（排行榜）

Game 包含 1 个 Menu（菜单）

Renderer 依赖 Board、Menu 和 RankList 来获取绘制数据，但不修改它们的状态（单向依赖）。

Animator 使用 MoveEvent 结构体列表来驱动动画，MoveEvent 描述了方块的移动信息（起点、终点、数值、类型）。

RankList 内部维护 RankNode 链表，RankNode 之间通过 next 指针连接。

2.2.2 重要数据结构

1. 二维数组（int grid_[4][4]）

Board 类的核心数据结构是一个 4×4 的整数数组。我选择使用原生数组而不是 std::vector，原因有二：一是性能更好（栈分配，无动态内存开销），二是大小固定为 4×4，不需要动态扩容。数组中的值表示方块的数值，0 表示空位置。

2. 单向链表（RankNode）*

排行榜使用手动管理的单向链表。每个节点包含三个字段：用户名（std::string）、分数（int）和指向下一节点的指针（RankNode*）。链表按分数降序排列，这样头节点始终是最高分。我实现了完整的链表操作：

插入：遍历链表找到第一个分数小于新节点的位置，插入到它前面

删除：遍历链表找到目标节点，调整前驱节点的 next 指针，释放内存

查找：线性遍历链表，比较用户名

为了防止内存泄漏，我在 RankList 的析构函数中实现了 clear() 方法，遍历整个链表并 delete 每个节点。

3. 事件列表（std::vector<MoveEvent>）

MoveEvent 是连接逻辑层和动画层的桥梁。它是一个结构体，包含：

type：事件类型（MOVE、MERGE、SPAWN）

fromRow、fromCol：起始网格坐标

toRow、toCol：目标网格坐标

value：方块数值

每次移动会生成 1 到 8 个 MoveEvent（取决于有多少方块移动和合并）。Animator 会将这些事件转换为 VisualTile 对象并驱动动画。

4. 视觉方块（VisualTile）

VisualTile 是动画系统的核心数据结构，它包含：

value：方块数值

startX、startY：动画起点的像素坐标（固定值）

currentX、currentY：当前帧的像素坐标（每帧更新）

targetX、targetY：动画终点的像素坐标（固定值）

scale：缩放比例（用于合并和生成动画）

动画状态标志（isMoving、isMerging、isSpawning）

关键设计决策是使用固定的 startX/Y，而不是在每一帧计算。这避免了线性插值时的"起点漂移"问题（如果用 currentX 作为起点，每帧都会重新计算，导致动画轨迹错误）。

2.3 主要算法思想
2.3.1 移动和合并算法

这是 2048 游戏的核心算法。我以向左移动为例说明算法思路：

对于每一行，算法分为三个阶段：

阶段1：收集非零值
遍历这一行，将所有非零值按顺序收集到临时数组 temp[] 中。例如 [2, 0, 2, 4] 收集后得到 [2, 2, 4]。

阶段2：合并相邻相同值
遍历 temp 数组，如果 temp[i] == temp[i+1]，则合并为 temp[i]*2，并跳过 i+1。关键点是使用一个 merged[] 数组存储合并结果，并且合并后要 ++i 跳过下一个元素，确保每个方块只合并一次。例如 [2, 2, 4] 合并后得到 [4, 4]。

阶段3：左对齐填充
将 merged 数组的内容从左到右写回原行，剩余位置填 0。例如 [4, 4] 写回后得到 [4, 4, 0, 0]。

这个算法的时间复杂度是 O(n)，其中 n=4。向右、向上、向下的算法思路相同，只是遍历顺序和写回顺序不同。

2.3.2 动画事件生成算法（computeMoveEvents）

这是本项目最复杂、也是我花费时间最多的算法。它需要解决一个核心问题：给定移动前后的两个网格快照，如何准确判断每个方块的移动轨迹和合并关系？

我经历了多次迭代才找到正确的解决方案。最初的简单匹配算法存在严重问题：它会让多个相同值的方块从同一个起点出发（导致"分身"），或者让方块斜向移动甚至反向移动（违反 2048 规则）。

最终的正确算法采用以下策略：

第一步：按移动方向的扫描顺序遍历 after 网格
这是标准 2048 实现的关键。向右移动时从右向左扫描，向左移动时从左向右扫描，向下移动时从下向上扫描，向上移动时从上向下扫描。这个顺序确保了先处理的方块不会"抢占"后处理方块的源。

第二步：判断当前位置是合并还是移动
我设计了一个多重检查机制：

如果目标位置在 before 中就有相同值且未使用，优先判定为"原地不动"

否则，检查 before 中是否有至少 2 个未使用的 halfValue（当前值的一半），如果有则判定为合并

最后检查是否有精确匹配的相同值，判定为普通移动

第三步：查找合并源时确保相邻性
对于合并事件，我需要找到两个 halfValue 源方块。但不能随意选择两个，必须选择位置连续的一对。我的做法是：

收集所有未使用的 halfValue 源

按移动方向排序（向右时按列号降序，向左时按列号升序）

在排序后的列表中查找第一对位置相差为 1 的方块

为这一对生成 MOVE 和 MERGE 事件

第四步：普通移动时添加方向验证
为了避免反向移动，查找普通移动的源时，我添加了方向约束：

// 向右移动时，源必须在目标左边或相同位置
if (dir == Direction::RIGHT) validDirection = (c <= afterCol);


这确保了方块只能沿着移动方向或原地不动，绝不会反向移动。

2.3.3 链表插入和更新算法

排行榜的 insertOrUpdate 算法结合了查找、删除和插入三个操作：

1. 调用 findNode 查找链表中是否已存在该用户名
2. 如果存在：
   a. 比较新旧分数
   b. 如果新分数更高，调用 remove 删除旧节点
   c. 创建新节点并调用 insertNode 有序插入
3. 如果不存在：
   直接创建新节点并调用 insertNode 有序插入


insertNode 的有序插入算法采用双指针法：

1. 如果链表为空或新节点分数大于头节点，插入到头部
2. 否则，用 current 指针遍历链表
3. 找到第一个 current->next->score < newNode->score 的位置
4. 将新节点插入到 current 和 current->next 之间


时间复杂度 O(n)，空间复杂度 O(1)。

2.4 设计表示
2.4.1 类的详细设计

Board 类

类型	成员名称	作用说明
数据成员		
int[4][4]	grid_	4×4 网格，存储方块数值（0 表示空）
int	score_	当前游戏分数
成员函数		
void	init()	初始化新游戏，清空网格并生成两个初始方块
MoveResult	simulateMove(Direction dir)	模拟移动并返回结果，不修改当前状态
void	commitGrid(const int newGrid[4][4])	提交新网格状态
pair<pair<int,int>,int>	spawnNewTile()	在随机空位生成新方块，返回位置和值
bool	hasWon()	检查是否出现 2048（胜利条件）
bool	isGameOver()	检查是否无法移动（失败条件）
void	moveLeft/Right/Up/Down(...)	四个方向的移动算法（私有）

Animator 类

类型	成员名称	作用说明
数据成员		
vector<VisualTile>	visualTiles_	当前动画中的所有视觉方块
bool	isAnimating_	动画是否正在播放
bool	isSpawning_	是否是生成动画（用于渲染判断）
float	animationTime_	当前动画已播放时间（秒）
float	moveDuration_	移动动画时长（0.2 秒）
float	mergeDuration_	合并弹出动画时长（0.1 秒）
成员函数		
void	startMoveAnimation(...)	启动移动/合并动画
void	startSpawnAnimation(...)	启动生成动画
void	update(float deltaTime)	每帧更新动画（60 FPS）
bool	isAnimating()	检查是否正在动画
void	setOnComplete(callback)	设置动画完成回调

RankList 类

类型	成员名称	作用说明
数据成员		
RankNode*	head_	链表头指针
string	rankFilePath_	排行榜文件路径
成员函数		
void	load()	从文件加载排行榜到链表
void	save()	将链表保存到文件
void	insertOrUpdate(name, score)	插入新记录或更新现有记录
bool	remove(username)	删除指定用户的记录
int	getBestScore()	获取最高分（头节点分数）
void	insertNode(node)	按分数有序插入节点（私有）
RankNode*	findNode(username)	查找节点（私有）

Menu 类

类型	成员名称	作用说明
数据成员		
string	playerName	玩家输入的名字
bool	hasSaveFile	是否有存档文件
bool	inputActive	输入框是否激活
Button	continueButton 等	各种按钮的位置和属性
成员函数		
void	handleTextInput(unicode)	处理文本输入（支持 UTF-8）
MenuAction	handleClick(x, y)	处理鼠标点击，返回菜单操作
void	updateHover(x, y)	更新鼠标悬停状态
bool	isButtonHovered(button)	检查按钮是否被悬停

Renderer 类

类型	成员名称	作用说明
数据成员		
RenderWindow&	window_	SFML 窗口引用
Font	font_	字体对象（支持中文）
float	cellSize_, gridStartX/Y	网格布局参数
成员函数		
bool	init()	初始化，加载字体
void	render(...)	绘制游戏界面
void	renderMenu(menu)	绘制菜单界面
void	renderRankList(...)	绘制排行榜
void	drawText(...)	绘制文本（支持 UTF-8）
void	drawButton(...)	绘制按钮（带悬停效果）

Game 类

类型	成员名称	作用说明
数据成员		
RenderWindow	window_	SFML 窗口对象
Board	board_	游戏逻辑
Animator	animator_	动画系统
Renderer	renderer_	渲染系统
SaveManager	saveManager_	存档管理
RankList	rankList_	排行榜
Menu	menu_	菜单
GameState	state_	当前游戏状态
成员函数		
void	run()	主循环
void	handleMove(dir)	处理移动输入
vector<MoveEvent>	computeMoveEvents(...)	生成动画事件
void	onMoveAnimationComplete(...)	移动动画完成回调
void	checkGameState()	检查胜负状态

2.5 实现注释
2.5.1 基本要求完成情况
要求	完成情况	说明
(1) 实现游戏规则	 100%	Board 类完整实现了所有 2048 规则
(2) 图形界面	 100%	使用 SFML 实现华丽的图形界面
(3) 文件存储进度	 100%	SaveManager 类实现 save.txt 读写
(4) 历史记录检测	 100%	启动时检测存档并提供选择
(5) 排名保存功能	 100%	RankList 类实现 ranks.txt 持久化
(6) 排名插入/修改	 100%	insertOrUpdate 方法实现
(7) 链表实现 CRUD	 100%	手动管理 RankNode* 链表
2.5.2 扩展功能实现

在完成基本要求的基础上，我还实现了以下扩展功能：

1. 完善的动画系统
这是本项目的最大亮点。我实现了三种动画：移动动画（线性插值）、合并动画（弹性缩放）、生成动画（缩放出现）。动画系统采用事件驱动设计，完全解耦于游戏逻辑。动画播放期间自动锁定输入，确保状态一致性。

2. 图形化菜单系统
实现了完全图形化的菜单界面，支持鼠标交互（点击按钮、悬停效果）和文本输入（UTF-8 编码，支持中文名字）。用户无需使用命令行，所有操作在图形窗口中完成。

3. 中文界面支持
通过加载 Noto Sans CJK 字体并使用 sf::String::fromUtf8 转换，实现了完整的中文界面支持。菜单、按钮、提示文字都使用中文显示，提升了用户体验。

4. 智能的游戏状态管理
实现了五状态状态机（菜单、游戏中、胜利、失败、排行榜），状态之间的转换逻辑清晰。例如游戏结束后自动保存分数到排行榜，然后返回菜单。

5. 调试辅助功能
添加了调试模式开关（DEBUG_INIT），可以固定初始网格方便测试特定场景。添加了事件日志输出，方便调试动画问题。

2.6 详细设计表示
2.6.1 移动算法框架

以 Board::moveLeft 为例，该算法是实现 2048 核心规则的关键函数：

算法框架：

函数: moveLeft(tempGrid[4][4], scoreGain)
输入: tempGrid - 当前网格（会被修改）
输出: scoreGain - 本次移动获得的分数

For each row in 0..3:
    1. 收集阶段：
       创建临时数组 temp[4]
       遍历该行，将非零值收集到 temp 中
    
    2. 合并阶段：
       创建合并数组 merged[4]
       For i in 0..temp.size:
           If temp[i] == temp[i+1]:
               merged[pos] = temp[i] * 2
               scoreGain += temp[i] * 2
               i++  // 跳过下一个
           Else:
               merged[pos] = temp[i]
           pos++
    
    3. 写回阶段：
       将 merged 数组从左到右写回该行
       剩余位置填 0


成员函数接口：

void moveLeft(int tempGrid[4][4], int& scoreGain) const;


参数：tempGrid 是网格的副本（会被就地修改），scoreGain 是输出参数

返回：无（通过引用参数返回结果）

副作用：修改 tempGrid，累加 scoreGain

2.6.2 动画事件生成算法框架

computeMoveEvents 是本项目的核心算法，也是解决动画"鬼畜"问题的关键：

算法框架：

函数: computeMoveEvents(gridBefore[4][4], gridAfter[4][4], dir)
输入: gridBefore - 移动前网格, gridAfter - 移动后网格, dir - 移动方向
输出: vector<MoveEvent> - 动画事件列表

初始化:
    events = []
    usedBefore[4][4] = false  // 标记已使用的源
    processedAfter[4][4] = false  // 标记已处理的目标

按扫描顺序遍历 afterGrid:
    确定扫描顺序（关键）:
        If dir == RIGHT: 从右到左遍历每行
        If dir == LEFT: 从左到右遍历每行
        If dir == DOWN: 从下到上遍历每列
        If dir == UP: 从上到下遍历每列
    
    For each 位置(row, col):
        value = gridAfter[row][col]
        If value == 0: continue
        
        // 判断是合并还是移动
        If gridBefore[row][col] == value 且未使用:
            类型 = 原地不动（MOVE，from==to）
        Else If 有 2 个以上未使用的 halfValue:
            类型 = 合并（MERGE）
            查找连续的一对源:
                收集所有 halfValue 源
                按方向排序
                找第一对相邻的（pos 相差 1）
                生成两个事件（MOVE + MERGE）
        Else:
            类型 = 普通移动（MOVE）
            查找最近的相同值源（限制方向）
        
        标记已处理: processedAfter[row][col] = true


成员函数接口：

std::vector<MoveEvent> computeMoveEvents(
    const int gridBefore[4][4], 
    const int gridAfter[4][4],
    Direction dir
);


关键创新点：

使用 processedAfter 数组，只检查已处理位置是否有相同值，避免误判

添加方向验证，确保源方块只能从移动反方向来

合并时查找连续对，避免"穿透合并"

2.6.3 链表有序插入算法框架

算法框架：

函数: insertNode(RankNode* node)
输入: node - 待插入节点（已分配内存）
输出: 无（修改链表）

If head == nullptr 或 node->score > head->score:
    // 插入到头部
    node->next = head
    head = node
    return

// 查找插入位置
current = head
While current->next != nullptr 且 current->next->score >= node->score:
    current = current->next

// 插入到 current 后面
node->next = current->next
current->next = node


成员函数接口：

void insertNode(RankNode* node);


前置条件：node 已通过 new 分配，score 和 username 已设置

后置条件：链表保持按分数降序排列

时间复杂度：O(n)，最坏情况需要遍历整个链表
三、用户手册
3.1 安装和运行
3.1.1 系统要求

操作系统：Linux（Ubuntu/Debian）、macOS 或 Windows

编译器：g++ 7.0 或更高版本（支持 C++17）

依赖库：SFML 2.5 或更高版本

推荐字体：Noto Sans CJK（中文界面支持）

3.1.2 安装 SFML

Ubuntu/Debian：

sudo apt-get install libsfml-dev


可选：安装中文字体

sudo apt-get install fonts-noto-cjk

3.1.3 编译
cd /home/lyl/ALL_C++/2048-motivate
make


编译成功后会显示：

编译完成! 运行 './2048' 或 'make run' 来启动游戏

3.1.4 运行
./2048


或者

make run

3.2 操作说明
3.2.1 主菜单界面

启动游戏后进入主菜单，界面包含：

游戏标题 "2048"

玩家名称输入框

功能按钮（根据是否有存档显示不同选项）

输入玩家名称：

鼠标点击输入框或直接在键盘上输入

支持中英文混合输入（UTF-8 编码）

最多输入 20 个字符

按 Backspace 删除字符

输入框激活时显示金色边框和闪烁光标

菜单操作（鼠标）：

移动鼠标到按钮上，按钮会变暗（悬停效果）

点击按钮执行对应操作

菜单操作（键盘快捷键）：

Enter键：如果有存档则继续游戏，否则开始新游戏

N键：开始新游戏（会删除旧存档）

R键：查看排行榜

ESC键：退出游戏

3.2.2 游戏界面

进入游戏后显示 4×4 彩色棋盘。

操作方式：

↑键：向上移动所有方块

↓键：向下移动所有方块

←键：向左移动所有方块

→键：向右移动所有方块

界面信息：

左上角：游戏标题和玩家名称

右上角：当前分数和历史最高分

中央：4×4 网格和彩色方块

底部：游戏状态提示（如"You Win!"或"Game Over!"）

自动保存：
每次有效移动后，游戏会自动保存进度到 save.txt 文件，无需手动操作。

游戏规则：

相同数值的方块在移动方向上碰撞时会合并

合并后数值翻倍，分数增加

每次有效移动后随机生成新方块（2 占 90%，4 占 10%）

出现 2048 方块时判定胜利（可继续游戏）

网格填满且无法移动时游戏失败

3.2.3 排行榜界面

点击"查看排行榜"按钮进入排行榜界面。

显示内容：

排行榜标题

玩家排名列表（格式：排名. 玩家名 - 分数）

最多显示前 10 名

如果无记录显示"暂无记录"

操作：

点击"返回菜单"按钮

按 ESC 键返回主菜单

3.2.4 游戏结束

游戏结束时显示最终分数并自动保存到排行榜。

操作：

按 R键 返回主菜单（可重新开始）

按 ESC键 返回主菜单

3.3 数据文件格式
3.3.1 进度文件（save.txt）
玩家名
分数
v00 v01 v02 v03
v10 v11 v12 v13
v20 v21 v22 v23
v30 v31 v32 v33


示例：

张三
1234
2 4 8 16
32 64 128 256
512 0 0 0
0 0 0 0


说明：

第一行：玩家名称（字符串，可包含中文）

第二行：当前分数（整数）

第 3-6 行：4×4 网格的数值（空格分隔）

3.3.2 排行榜文件（ranks.txt）
用户名1 分数1
用户名2 分数2
...


示例：

张三 12345
李四 9876
王五 5432


说明：

每行一条记录，用户名和分数用空格分隔

文件已按分数降序排列（程序自动维护）

同一用户名只保留最高分

3.4 注意事项

首次运行：首次运行时会创建空的 save.txt 和 ranks.txt 文件

玩家名称：如果不输入名称，默认使用"玩家"作为用户名

窗口焦点：操作前请确保游戏窗口处于激活状态

动画锁定：动画播放期间无法进行下一次移动，这是正常现象

文件编码：所有文件使用 UTF-8 编码保存

四、调试及测试
4.1 调试过程中遇到的主要问题

在开发过程中，我遇到了多个技术难题，这些问题的解决过程让我对 C++ 编程和游戏开发有了更深入的理解。

4.1.1 动画"分身"和"穿透"问题

问题描述：
最初实现动画时，出现了严重的视觉 bug。例如对于网格 2 2 2 4，向右移动后，屏幕上会出现多个 2 从同一个位置"分裂"出来，或者看到方块跨越中间的方块进行合并（如第 1 个和第 3 个 2 合并，跳过了第 2 个）。

问题根源：
我最初使用"事后推导"的方式生成动画事件。对比移动前后的网格，简单地在 gridBefore 中查找相同值作为源。但当有多个相同值方块时（如三个 2），这个算法会让所有 2 都从第一个找到的 2 的位置出发，导致"分身"现象。

解决方案：
我采用了标准 2048 动画算法：

添加 usedBefore 数组标记已使用的源，避免重复匹配

按移动方向的扫描顺序遍历 after（向右从右到左，向左从左到右）

合并时查找位置连续的一对源，使用 abs(pos1 - pos2) == 1 判断相邻性

添加 processedAfter 数组，只检查已处理位置的信息，避免误判

这个过程耗费了大量调试时间，通过打印事件日志、模拟不同场景、逐步完善判断条件，最终解决了所有"穿透"和"分身"bug。

4.1.2 动画期间方块消失问题

问题描述：
在移动动画完成、生成动画开始的瞬间，屏幕上所有方块会消失一帧，然后只显示新生成的方块，其他方块"凭空出现"。

问题根源：
渲染器有一个逻辑：如果 visualTiles 不为空，只绘制 visualTiles；否则绘制 Board。但是在生成动画时，visualTiles 只包含 1 个新方块，Board 已经更新为包含所有方块的最终状态，但渲染器只画了 visualTiles，导致其他方块不显示。

解决方案：
我实现了分层渲染策略：

移动/合并动画：visualTiles 包含所有方块 → 只画 visualTiles

生成动画：visualTiles 只有新方块 → 先画 Board 背景，再画 visualTiles 覆盖

静态状态：visualTiles 为空 → 只画 Board

在 Animator 中添加 isSpawning_ 标志区分动画类型，渲染器根据这个标志选择绘制策略。

4.1.3 方块反向移动问题

问题描述：
对于 2 2 4 2 向右移动，正确结果是 0 4 4 2（左边两个 2 合并，右边的 4 和 2 不动）。但动画显示：合并产生的 4 向右移动，原来的 4 向左移动，两者交换位置。虽然最终结果正确，但动画过程违反了物理规律。

问题根源：
在查找普通移动的源时，没有限制方向。向右移动时，如果目标在位置 2，算法会在整行中查找相同值，可能找到位置 3 的方块，导致"反向移动"。

解决方案：
在普通移动查找源时添加方向验证：

bool validDirection = false;
if (dir == Direction::RIGHT) validDirection = (c <= afterCol);
else if (dir == Direction::LEFT) validDirection = (c >= afterCol);
// ...
if (!validDirection) continue;


这确保了：

向右移动时，源只能在目标左边或相同位置

向左移动时，源只能在目标右边或相同位置

向下移动时，源只能在目标上边或相同位置

向上移动时，源只能在目标下边或相同位置

4.1.4 中文字体显示问题

问题描述：
菜单中的中文显示为方框或乱码。

问题根源：
SFML 的 Text::setString 方法默认按 ASCII 处理字符串，不支持 UTF-8 多字节字符。

解决方案：
使用 sf::String::fromUtf8 进行转换：

sf::String unicodeString = sf::String::fromUtf8(text.begin(), text.end());
textObj.setString(unicodeString);


同时加载支持中文的字体（Noto Sans CJK），并实现多级 fallback 机制，确保在不同系统上都能正确显示中文。

4.2 对设计和编码的回顾
4.2.1 架构设计的成功之处

回顾整个项目，我认为分层架构的决策非常正确。将逻辑、动画、渲染分离后，每一层都可以独立开发和测试。例如我可以先完成 Board 类的所有移动算法并用简单的 cout 验证正确性，然后再去实现动画系统。这种自底向上的开发方式降低了复杂度。

事件驱动的动画系统也是一个成功的设计。通过 MoveEvent 这个中间抽象，逻辑层和动画层完全解耦。未来如果要更换图形库（从 SFML 换成其他库），只需重写 Renderer 和 Animator，Board 类完全不需要修改。

4.2.2 编码中的教训

过早优化是万恶之源。 在实现 computeMoveEvents 时，我一开始试图设计一个"万能算法"一次性解决所有情况，结果逻辑越来越复杂，bug 层出不穷。后来我转变思路，针对每个具体场景（如 2 2 2 4）单独分析，找出判断条件，逐步完善算法。最终虽然代码行数增加了，但逻辑清晰，bug 也都解决了。

调试工具的重要性。 添加事件日志输出极大地帮助了我定位问题。每次移动都打印 before/after 网格和生成的事件列表，我可以直观地看到算法哪里出错了。这比盲目地猜测和修改代码高效得多。

测试驱动开发的价值。 我实现了 DEBUG_INIT 模式，可以固定初始网格为特定值（如 2 2 2 4），这让我能够重复测试同一场景，快速验证修改是否有效。如果每次都靠随机生成等待特定场景出现，调试效率会非常低。

4.3 程序运行效率分析
4.3.1 时间复杂度分析

游戏逻辑（Board 类）：

移动算法：O(1)，因为网格大小固定为 4×4，遍历 16 个单元格是常数时间

胜负判断：O(1)，最多遍历 16 个单元格

生成新方块：O(1)，收集空位最多 16 个，随机选择是 O(1)

动画事件生成（computeMoveEvents）：

外层循环：遍历 4×4 = 16 个位置

内层查找源：最坏情况遍历 16 个位置

总体：O(16×16) = O(256) = O(1)（常数时间）

排行榜操作（RankList 类）：

插入：O(n)，n 为链表长度（通常 < 100）

查找：O(n)

删除：O(n)

获取最高分：O(1)

整体性能：
由于网格大小固定，游戏的核心操作都是常数时间。排行榜操作虽然是 O(n)，但 n 很小且操作频率低（只在游戏结束时），对整体性能影响可忽略。

4.3.2 空间复杂度分析

Board 类：O(1)，固定大小的 4×4 数组

Animator 类：O(k)，k 为同时移动的方块数量（最多 16）

RankList 类：O(n)，n 为排行榜记录数

临时数组和快照：O(1)，固定大小

总体空间复杂度：O(n)，n 为排行榜大小，通常很小。

4.3.3 帧率性能

游戏设置为 60 FPS（每帧 ~16.7ms）。实际测试中，单帧渲染时间约 2-3ms（包括动画更新和 SFML 绘图），CPU 占用率低，运行流畅。即使在低配置电脑上也能保持稳定的 60 FPS。

4.4 测试数据集

为了全面验证游戏功能，我设计了以下测试用例：

4.4.1 移动和合并规则测试

测试用例 1：基本合并

输入：2 2 0 0，向左移动

期望输出：4 0 0 0

测试目的：验证相邻相同方块能正确合并

结果： 通过

测试用例 2：多重合并

输入：2 2 2 2，向左移动

期望输出：4 4 0 0

测试目的：验证一次移动中多个合并操作

结果： 通过

测试用例 3：不合并的移动

输入：2 4 8 16，向左移动

期望输出：2 4 8 16（无变化）

测试目的：验证无效移动不生成新方块

结果： 通过

测试用例 4：复杂场景

输入：2 2 2 4，向右移动

期望输出：0 2 4 4

测试目的：验证正确的合并顺序（右边两个 2 合并）

结果： 通过（经过多次调试修复）

测试用例 5：垂直移动

输入：垂直方向的 2 2 2 4，向下移动

期望输出：0 2 4 4

测试目的：验证垂直方向算法正确性

结果： 通过

4.4.2 动画系统测试

测试用例 6：移动动画

输入：0 4 0 0，向左移动

期望动画：4 从位置 1 平滑滑动到位置 0

测试目的：验证移动动画的流畅性

结果： 通过，200ms 线性插值动画流畅

测试用例 7：合并动画

输入：2 2 0 0，向左移动

期望动画：两个 2 都向左移动到位置 0，然后变成 4 并弹出

测试目的：验证合并动画的正确性

结果： 通过，合并后正确显示 1.0→1.2→1.0 的缩放动画

测试用例 8：输入锁定

操作：快速连续按方向键

期望行为：第一次移动的动画播放完毕前，忽略后续输入

测试目的：验证输入锁定机制

结果： 通过，不会出现状态不一致

测试用例 9：反向移动检测

输入：2 2 4 2，向右移动

期望动画：左边两个 2 向右合并，右边的 4 和 2 不动（不能反向移动）

测试目的：验证方向验证机制

结果： 通过（添加 validDirection 检查后修复）

4.4.3 持久化测试

测试用例 10：保存和加载

操作：进行若干移动后退出，重新启动游戏并选择继续

期望结果：网格、分数、玩家名完全恢复

结果： 通过

测试用例 11：排行榜插入

操作：以不同用户名完成游戏

期望结果：排行榜按分数降序排列

结果： 通过

测试用例 12：排行榜更新

操作：同一用户名多次游戏，第二次分数更高

期望结果：保留更高分，删除旧记录

结果： 通过

4.4.4 边界条件测试

测试用例 13：网格填满

输入：手动设置网格填满且无相邻相同值

期望结果：显示"Game Over"

结果： 通过

测试用例 14：达到 2048

输入：手动设置网格包含 2048

期望结果：显示"You Win"

结果： 通过

测试用例 15：空输入

操作：不输入玩家名称直接开始游戏

期望结果：使用默认名称"玩家"

结果： 通过

4.5 运行实例

以下是一次完整的游戏流程示例：

启动游戏：

$ ./2048
成功加载字体: NotoSansCJK-Bold.ttc


主菜单：

屏幕显示：标题"2048"，输入框，"开始游戏"按钮

操作：输入玩家名"测试玩家"，点击"开始游戏"

游戏过程：

初始网格:
2 0 0 0
0 0 0 2
0 0 0 0
0 0 0 0

按→键（向右移动）:
=== Move Events ===
Direction: RIGHT
Before: 2 0 0 0
After:  0 0 0 2
Events:
0: MOVE  (0,0)→(0,3) value=2
===================

动画播放: 2 从位置 0 平滑滑动到位置 3
生成新方块后的网格:
0 0 0 2
0 0 0 2
0 0 2 0
0 0 0 0

按↓键（向下移动）:
=== Move Events ===
Direction: DOWN
Events:
0: MOVE  (0,3)→(3,3) value=2
1: MERGE (1,3)→(3,3) value=2
2: MOVE  (2,2)→(3,2) value=2
===================

动画播放: 
- (0,3)的2向下滑到(3,3)
- (1,3)的2向下滑到(3,3)并合并成4，弹出动画
- (2,2)的2向下滑到(3,2)

最终分数: 4


游戏结束：

继续游戏直到无法移动

显示"Game Over! Press R to restart..."

最终分数：1234

自动保存到排行榜

查看排行榜：

排行榜
1. 测试玩家 - 1234
2. 玩家 - 568

4.6 改进设想

虽然当前实现已经满足了所有课程要求，但仍有改进空间：

1. 撤销功能（Undo）
可以维护一个历史栈，记录每次移动前的网格状态，允许玩家撤销操作。这需要在 Game 类中添加 std::stack<BoardState> 成员。

2. 更华丽的动画效果
当前使用线性插值，可以改用缓动函数（Easing Functions）如 EaseInOut，使动画更有"弹性"和"生命力"。可以使用开源库如 Robert Penner's Easing Functions。

3. 音效系统
添加背景音乐和音效（移动、合并、胜利的声音），使用 SFML 的 Audio 模块可以轻松实现。

4. 多种游戏模式
实现 5×5 网格、限时模式、挑战模式等变体，增加游戏可玩性。

5. 网络排行榜
使用 HTTP 库将排行榜上传到服务器，实现全球排名。

6. 触摸屏支持
添加滑动手势识别，支持触摸屏设备。

7. 主题切换
实现多套配色方案（如暗色主题、护眼模式），可以在菜单中选择。

4.7 经验和体会

通过这次课程设计，我获得了以下宝贵经验：

1. 架构设计的重要性
一个好的架构可以让后续开发事半功倍。分层架构让我在遇到动画 bug 时，能够快速定位是哪一层的问题，而不是在一团乱麻的代码中盲目查找。

2. 调试技巧的提升
学会了使用日志输出、固定测试用例、模拟运行等调试方法。特别是"模拟运行"——在纸上或脑中逐步执行算法，手动计算中间变量的值，这比单纯依赖 gdb 更能帮助我理解算法逻辑。

3. 代码规范的价值
严格的命名规范（如私有成员加 _ 后缀）、清晰的注释、统一的代码风格，这些看似琐碎的细节在项目规模扩大后变得至关重要。当代码超过 2000 行时，如果没有规范，维护会非常痛苦。

4. 文档和版本控制
虽然本课程设计没有强制要求使用 Git，但我在开发过程中深刻体会到版本控制的必要性。多次因为"改坏了"想回退代码而后悔没有提交版本。未来的项目一定会使用 Git。

5. 用户体验的细节
添加鼠标悬停效果、输入框光标闪烁、中文界面支持，这些细节大大提升了用户体验。一个功能正确但界面粗糙的程序，和一个功能正确且界面精致的程序，给人的感觉完全不同。

6. 从失败中学习
这个项目中我遇到了无数 bug，从"方块分身"到"反向移动"，每一个 bug 的解决都让我对算法和系统设计有了更深入的理解。失败不可怕，重要的是分析原因、总结经验、持续改进。

总结：
这次课程设计让我真正理解了"软件工程"不仅是写代码，更是设计架构、调试测试、优化性能、撰写文档的综合过程。通过实践掌握了 C++ 面向对象编程、SFML 图形库、链表数据结构、状态机模式、事件驱动架构等技术，收获颇丰。

附录A：核心源代码清单
A.1 Board 类关键代码（移动算法）
void Board::moveLeft(int tempGrid[4][4], int& scoreGain) const {
    scoreGain = 0;
    
    for (int row = 0; row < 4; ++row) {
        int temp[4] = {0};
        int pos = 0;
        
        // 阶段1：收集非零值
        for (int col = 0; col < 4; ++col) {
            if (tempGrid[row][col] != 0) {
                temp[pos++] = tempGrid[row][col];
            }
        }
        
        // 阶段2：合并相同值
        int merged[4] = {0};
        int mergePos = 0;
        
        for (int i = 0; i < pos; ++i) {
            if (i + 1 < pos && temp[i] == temp[i + 1]) {
                // 合并
                merged[mergePos++] = temp[i] * 2;
                scoreGain += temp[i] * 2;
                ++i; // 关键：跳过下一个已合并的
            } else {
                merged[mergePos++] = temp[i];
            }
        }
        
        // 阶段3：写回行
        for (int col = 0; col < 4; ++col) {
            tempGrid[row][col] = merged[col];
        }
    }
}


算法说明：
这段代码实现了 2048 的核心规则"每个方块每次移动只合并一次"。通过 ++i 跳过已合并的方块，确保不会发生连续合并。

A.2 RankList 类关键代码（链表操作）
void RankList::insertOrUpdate(const std::string& username, int score) {
    RankNode* existing = findNode(username);
    
    if (existing != nullptr) {
        // 用户已存在
        if (score > existing->score) {
            // 新分数更高，删除旧记录并插入新记录
            remove(username);
            RankNode* newNode = new RankNode(username, score);
            insertNode(newNode);
        }
    } else {
        // 新用户，直接插入
        RankNode* newNode = new RankNode(username, score);
        insertNode(newNode);
    }
}

void RankList::insertNode(RankNode* node) {
    // 按分数降序插入
    if (head_ == nullptr || node->score > head_->score) {
        node->next = head_;
        head_ = node;
        return;
    }
    
    // 查找插入位置
    RankNode* current = head_;
    while (current->next != nullptr && current->next->score >= node->score) {
        current = current->next;
    }
    
    // 插入
    node->next = current->next;
    current->next = node;
}


算法说明：
这段代码实现了排行榜的核心逻辑。insertOrUpdate 先查找是否存在，存在则比较分数决定是否更新。insertNode 使用有序插入算法保持链表按分数降序排列。

A.3 Animator 类关键代码（动画更新）
void Animator::update(float deltaTime) {
    if (!isAnimating_) return;
    
    // 防御：限制最大 deltaTime 避免跳帧
    if (deltaTime > 0.1f) deltaTime = 0.1f;
    
    animationTime_ += deltaTime;
    bool allComplete = true;
    
    for (auto& tile : visualTiles_) {
        if (tile.isMoving) {
            // 移动阶段
            float moveT = std::min(1.0f, animationTime_ / moveDuration_);
            
            // 关键：使用固定的 startX/Y 做线性插值
            tile.currentX = lerp(tile.startX, tile.targetX, moveT);
            tile.currentY = lerp(tile.startY, tile.targetY, moveT);
            tile.scale = 1.0f;
            
            if (moveT < 1.0f) {
                allComplete = false;
                continue;
            }
            
            // 合并弹出阶段
            if (tile.isMerging) {
                if (!tile.mergeValueUpdated) {
                    tile.value = tile.value * 2;  // 显示合并后的值
                    tile.mergeValueUpdated = true;
                }
                
                float mergeT = std::min(1.0f, 
                    (animationTime_ - moveDuration_) / mergeDuration_);
                
                // 弹性缩放：1.0 -> 1.2 -> 1.0
                if (mergeT < 0.5f) {
                    tile.scale = 1.0f + (mergeT / 0.5f) * 0.2f;
                } else {
                    tile.scale = 1.2f - ((mergeT - 0.5f) / 0.5f) * 0.2f;
                }
                
                if (mergeT < 1.0f) allComplete = false;
            }
        }
        // ... 生成动画逻辑省略
    }
    
    if (allComplete) {
        isAnimating_ = false;
        visualTiles_.clear();
        if (onComplete_) onComplete_();
    }
}


算法说明：
这段代码实现了动画的核心逻辑。使用 deltaTime 累加计算进度，通过线性插值更新位置，通过二次函数实现弹性缩放。关键是分阶段处理：先移动，移动完成后再播放合并弹出动画。
A.4 完整项目文件列表
2048-motivate/
├── main.cpp                 # 主函数入口
├── Makefile                 # 编译配置
├── README.md                # 项目说明
├── include/                 # 头文件目录
│   ├── Board.h              # 游戏逻辑
│   ├── MoveEvent.h          # 动画事件定义
│   ├── Animator.h           # 动画系统
│   ├── Renderer.h           # 渲染器
│   ├── SaveManager.h        # 存档管理
│   ├── RankList.h           # 排行榜（链表）
│   ├── Menu.h               # 菜单系统
│   └── Game.h               # 游戏主控制器
├── src/                     # 实现文件目录
│   ├── Board.cpp
│   ├── Animator.cpp
│   ├── Renderer.cpp
│   ├── SaveManager.cpp
│   ├── RankList.cpp
│   ├── Menu.cpp
│   └── Game.cpp
├── obj/                     # 目标文件目录
│   └── *.o                  # 编译生成的目标文件
├── save.txt                 # 游戏存档（自动生成）
└── ranks.txt                # 排行榜数据（自动生成）


代码统计：

头文件：8 个

实现文件：7 个

总代码行数：约 2500 行（含注释）

类数量：7 个主要类 + 3 个辅助结构体

附录B：测试数据和运行结果
B.1 移动算法测试

输入1： [2, 2, 2, 2] 向左
输出1： [4, 4, 0, 0] 
分数增加： 8

输入2： [2, 2, 2, 4] 向右
输出2： [0, 2, 4, 4] 
事件： 2 个移动 + 1 个合并

输入3： [2, 2, 4, 2] 向右
输出3： [0, 4, 4, 2] 
验证： 左边两个 2 合并，右边 4 和 2 不动（无反向移动）

B.2 排行榜测试

初始状态： 空链表

操作1： 插入 ("玩家A", 100)
链表： 玩家A(100) → null

操作2： 插入 ("玩家B", 200)
链表： 玩家B(200) → 玩家A(100) → null

操作3： 更新 ("玩家A", 150)
链表： 玩家B(200) → 玩家A(150) → null
验证： 保留更高分，链表仍有序

操作4： 删除 "玩家B"
链表： 玩家A(150) → null
验证： 头节点正确删除

B.3 完整游戏流程测试

场景： 从启动到游戏结束的完整流程

步骤	操作	结果	验证
1	启动游戏	显示主菜单	
2	输入名字"张三"	输入框显示"张三|"	 中文正常
3	点击"开始游戏"	进入游戏，初始网格有两个方块	
4	按→键	方块向右移动，动画流畅	
5	快速连按→键	只执行一次移动，输入被锁定	
6	继续游戏至结束	显示"Game Over"	
7	按R返回菜单	回到主菜单	
8	点击"查看排行榜"	显示"1. 张三 - 分数"	